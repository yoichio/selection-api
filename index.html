<!DOCTYPE html>
<html>
  <head>
    <title>ComposedSelection API</title>
    <meta charset='utf-8'>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' async class='remove'></script>
    <script class='remove'>
      var respecConfig = {
        specStatus: "ED",
        shortName: "ComposedSelection",
        editors: [
          {
            name: "Yoichi Osato",
            mailto: "yoichio@google.com",
            company: "Google Inc.",
            companyURL: "https://www.google.com/",
            w3cid: "49814",
          },
        ],
        wg: "Web Platform Working Group",
        wgURI: "https://www.w3.org/WebPlatform/WG/",
        wgPublicList: "public-webapps",
        wgPatentURI: "https://www.w3.org/2004/01/pp-impl/83482/status",
        testSuiteURI: "TBD",
        github: "TBD",
      };
    </script>
    <style>
      ol.nest { counter-reset: item }
      ol.nest li { display: block }
      ol.nest li:before { content: counters(item, ".") "."; counter-increment: item }
    </style>
  </head>
  <body>
    <section id='abstract'>
      <p>
        This document is a preliminary draft of a specification for the ComposedSelection API and selection related functionality.
        ComposedSelection enables web authors to get/set selection
        considering <a href="https://www.w3.org/TR/dom41/#dom-element-attachshadow">Shadow DOM</a>.
      </p>
      <p>
	This document defines APIs for selection, which allows users and authors to select a portion of a document or specify a point of interest for copy, paste, and other editing operations.
      </p>
    </section>
    
    <section id='sotd'>
      <p>Any feedback or discussion of this specification should be sent to the
        <a href="mailto:public-webapps@w3.org">public-webapps mailing list</a>
        with "[selection-api]" as the Subject header prefix
        (<a href="https://lists.w3.org/Archives/Public/public-webapps/">archive</a>).
      </p>

      <p>
        This specification is based on the <a href="http://w3c.github.io/selection-api/">Selection API</a>
        edited by Ryosuke Niwa.
      </p>
    </section>

    <section class="informative">
      <h2>Background</h2>

      <p>Chrome69, Safari12 and Firefox64 support Shadow DOM.<br>
        Chrome69 supports user selection crossing/inside shadow and copy/paste. 
        document.getSelection() and shadowRoot.getSelection() only work well if selection is inside a single node tree. <br>
        Safari12 supports user selection crossing/inside shadow and it doesn't support shadowRoot.getSelection(). <br>
        Firefox64 supports user selection inside shadow and it doesn't support shadowRoot.getSelection(). </p>
      <p>
        Existing <a href="http://w3c.github.io/selection-api/">Selection API</a> specifies that there is single selection in a document and the selection is bound to
        single <a href="https://dom.spec.whatwg.org/#range">Range</a>, which can't represent a range over composed tree. <br> 
        For backward compatibility, we can't update <a href="http://w3c.github.io/selection-api/">Selection API</a> so that it can get/set nodes in other node trees. </p>

      <p>So I suggest new API that lets web authors to control selection in composed tree.</p>

      <div class=note>
      <p>See <a href="https://github.com/w3c/webcomponents/issues/79">webcomponents issue 79</a> for more history and detail.</p>
      </div>

      <p>This API is intent to get/set fine-grain selection range while keeping document.getSelection() compatibility and ShadowRoot closeness.</p>
      <div class="example">
      <pre><code class="lang-html">
&lt;!DOCTYPE html>
&lt;script>
customElements.define('x-editor', class extends HTMLElement {
  constructor() {
    super();
    let input = document.createElement('input');
    let div = document.createElement('div');
    div.contenteditable = true;
    div.innerHTML = "initial text";
    this.appendChild(input);
    this.appendChild(div);
    // &lt;input>
    // &lt;div>initial text&lt;/div>
    input.value = "selectall";
    input.onlick = () => {
      let range = document.createRange();
      range.setStart(div, 0);
      range.setEnd(div, 1);
      document.getselection().addRange(range);
    };
  }
});
&lt;/script>
&lt;x-editor>&lt;/x-editor>
      </code></pre>

      This x-editor element creates a tyny editor having "selectall" button.
      However this won't work if this element is composed in shadow.
      <pre><code class="lang-html">
&lt;!DOCTYPE html>
&lt;script>
customElements.define('big-component', class extends HTMLElement {
  constructor() {
    super();
    let shadow = this.attachShadow({mode:"open"});
    shadow.innerHTML = '
    &lt;x-editor>&lt;/x-editor>
    &lt;baz-element>&lt;/baz-element>
    &lt;foo-element>&lt;/foo-element>
    ';
    };
  }
});
&lt;/script>
&lt;big-component>&lt;/big-component>
      </code></pre>

      This doesn't work because div in x-editor is inside Shadow tree, <code>range.setStart(div,0)</code> prohibits it.
      Furthermore, big-component author nor top page auther can't get selection range if the div is selected even big-component's ShadowRoot is open.
      Plus, even if an enclosing ShadowRoot is closed, editor author want to manage selection.
      </div>

      <div class="example">
        Some selection sample for crossing Shadow.
      </div>
    </section>

    <section id='conformance'>
      <p>
        This specification defines conformance criteria that apply to a single
        product: the <dfn id="ua">user agent</dfn> that implements the
        interfaces that it contains.
      </p>
      <p>
        Implementations that use ECMAScript to implement the APIs defined in
        this specification must implement them in a manner consistent with the
        ECMAScript Bindings defined in the Web IDL specification [[!WEBIDL-1]],
        as this specification uses that specification and terminology.
      </p>
    </section>

    <section>
      <h2>Definition</h2>

      <p>Every 
          <dfn><a href="https://html.spec.whatwg.org/multipage/window-object.html#the-window-object">window</a></dfn> ([[!HTML]])
         which associates a <dfn><a href="https://www.w3.org/TR/dom/#document">document</a></dfn> ([[!DOM]])
        in a <dfn><a href="https://www.w3.org/TR/html5/browsers.html#browsing-context">browsing context</a></dfn> ([[!HTML]])
        has a unique <dfn>selection</dfn> associated with it.</p>

      <p>Each <a>selection</a> can be associated with a <dfn>selection range</dfn>, which has two <a href="https://www.w3.org/TR/dom/#concept-range-bp"><dfn>boundary point</dfn></a>s: <dfn>base</dfn> and <dfn>extent</dfn>.
         When there is no <a>selection range</a> associated with the <a>selection</a>, the </a>selection</a> is <dfn>empty</dfn>.
        The selection must be initially <a>empty</a>.
      </p>
      <p class=note>base node and extent node can be in different node tree and no order consraint between them unlike DOM <dfn data-cite="!DOM#range">range</dfn>.</p>

      <p>This one <a>selection</a> must be shared by all the content of the <a>document</a> and its shadow trees
        (though not by nested <a>browsing context</a>s)</p>
    </section>

    <section data-dfn-for="SelectionRange">
      <h2>SelectionRange interface</h3>
      <p>SelectionRange interface represents a <a>selection range</a>.</p>
      <pre class="idl">
        interface SelectionRange {
          readonly attribute Node baseNode;
          readonly attribute unsigned long baseOffset;
          readonly attribute Node extentNode;
          readonly attribute unsigned long extentOffset;
        };
      </pre>
      <dl>
        <dt><dfn>baseNode</dfn></dt>
        <dd>
          <p>The attribute must return the <a>base</a> <dfn><a href="https://www.w3.org/TR/dom/#concept-node">node</a></dfn> ([[!DOM]])
          of the <dfn><a href="https://www.w3.org/TR/dom/#context-object">context object</a></dfn> ([[!DOM]]).
        </dd>

        <dt><dfn>baseOffset</dfn></dt>
        <dd>
          <p>The attribute must return the <a>base</a> <dfn><a href="https://www.w3.org/TR/dom/#concept-range-bp-offset">offset</a></dfn> ([[!DOM]])
          of the <a>context object</a>.</p>
        </dd>

        <dt><dfn>extentNode</dfn></dt>
        <dd>
          <p>The attribute must return the <a>extent</a> <a>node</a> of the <a>context object</a>.</p>
        </dd>

        <dt><dfn>extentOffset</dfn></dt>
        <dd>
          <p>The attribute must return the <a>extent</a> <a>offset</a> of the <a>context object</a>.</p>
        </dd>
      </dl>
      <div class=note>
        This could be compatible to Range if both node is in a node tree?
      </div>
    </section>

    <section data-dfn-for="ComposedSelection">
      <h2>ComposedSelection interface</h2>
      <p>ComposedSelection interface provides a way to interact with the <a>selection</a>
        associated with each window.
      </p>

      <pre class="idl">
        interface ComposedSelection {
          SelectionRange? getRange(optional sequence&lt;ShadowRoot&gt; disclosedShadows = []);
          void clear();
          void setBaseAndExtent(Node baseNode, unsigned long baseOffset, Node extentNode, unsigned long extentOffset);
        };
      </pre>
      <dl>
        <dt><dfn>getRange</dfn></dt>
        <dd>
          <p>The method must follow these steps.</p>
          <ol class=nest>
            <li>If <a>selection</a> is <a>empty</a>, return null. </li>
            <li> Let <var>range base node</var> be <a>base</a> node and <var>range base offset</var> be <a>base</a> offset.</li>
            <li> If <var>range base node</var>'s root is not document, repeat following steps:
              <ol class=nest>
                <li> Let <var>root</var> be <var>range base node</var>'s root.</li>
                <li> The root must be ShadowRoot. If the root is in <var>disclosedShadows</var>, abort this step.</li>
                <li> If the root is closed ShadowRoot, Set range base node be its host and range base offset 0.</li>
                <li> Set root be the root's host's root.
                <li> If root is document, abort this step. Otherwise, Go back to step 3.2. </li>
              </ol>              
            </li>
            <li> Ditto to <var>range extent node</var> and <var>range extent offset</var>.</li>
            <li>Return SelectionRange of <var>range base node</var>, <var>range base offset</var>, <var>range extent node</var> and <var>range extent offset</var>. </li>
          </ol>
          <div class=note>
            getRange is intent to get fine-grain range while keeping document.getSelection() compatibility and ShadowRoot closeness.
            <ol>
              <li>If no closed ShadowRoot ancestor of <a>base</a> and <a>extent</a>, 
                <ol>
                  <li> getRange() must return exact <a>base</a> and <a>extent</a>.</li>
                  <li> Plus if base and extent has same root, the SelectionRange must be converted to Range even in ShadowRoot.</li>
                </ol>
              </li>
            <li>If there is a closed ShadowRoot ancestor of each node,
              <ol>
                <li> This method adopts the host node of shallowest closed ShadowRoot while considering shadow roots in disclosedShadows as accessible. </li>
                <li> If web author has a reference of a closed ShadowRoot and selection is inside the root, getRange(closedRoot) return virtually Range of the ShadowRoot. </li>
              </ol>               
            </li>
            </ol>
            <pre class='example highlight'>
      
             </pre>
          </div>
        </dd>

        <dt><dfn>clear</dfn></dt>
        <dd>
            <p>The method must make the <a>context object</a> <a>empty</a> by clearing 
              <a>context object</a>'s <a>base</a> and <a>extent</a>.</p>
        </dd>

        <dt><dfn>setBaseAndExtent</dfn></dt>
        <dd>
          <p>The method must set <a>context object</a>'s <a>directional range</a> following these steps:</p>
          <p>TBD</p>
          <!--ol>
            <li>If <var>baseOffset</var> is longer than <var>baseNode</var>'s <a>length</a>
              or if <var>extentOffset</var> is longer than <var>extentNode</var>'s <a>length</a>,
              throw an <a>IndexSizeError</a> exception and abort these steps.</li>
            <li>If the <a>root</a>s of <var>baseNode</var> or <var>extentNode</var> are not the <a>document</a> associated with <a>context object</a>,
              abort these steps.</li>
            <li>Let <var>base</var> be the <a>boundary point</a> (<var>baseNode</var>, <var>baseOffset</var>)
              and let <var>extent</var> be the <a>boundary point</a> (<var>extentNode</var>, <var>extentOffset</var>).</li>
            <li>Let <var>newRange</var> be a new <a>range</a>.</li>
            <li>If <var>base</var> is <a>before</a> <var>extent</var>,
              <a href="#range-set">set</a> the <var>newRange</var>'s <a href="#range-start">start</a> to <var>base</var>
              and its <a href="#range-end">end</a> to <var>extent</var>.
              Otherwise, <a href="#range-set">set</a> them to <var>extent</var> and <var>base</var> respectively.</li>
            <li>Set the <a>context object</a>'s <a>range</a> to <var>newRange</var>.</li>
            <li>If <var>extent</var> is <a>before</a> <var>base</var>, set <a>context object</a>'s <a>direction</a> to <a>backwards</a>.
              Otherwise, set it to <a>forwards</a></li>
          </ol -->
        </dd>
      </dl>

      
    </section>

    <section>
      <h2>Extensions to Other Interfaces</h2>

      <p>This specification extends several interfaces to provide entry points to the
      interfaces defined in this specification.</p>

      <section data-dfn-for="Window">
        <h3>Extensions to <code>Window</code> interface</h3>
        <pre class="idl">
          partial interface Window {
            ComposedSelection ? getComposedSelection();
          };
        </pre>
        <dl>
          <dt><dfn>getComposedSelection()</dfn></dt>
          <dd>
            <p>The method must return the <a>selection</a> associated with <a>context object</a>
              if the <a>context object</a> has an associated <a>browsing context</a>,
              and it must return <code>null</code> otherwise.</p>
          </dd>
        </dl>
      </section>

      <section data-dfn-for="GlobalEventHandlers">
        <h3>Extensions to <code>GlobalEventHandlers</code></h3>
        <p>
          The <code><dfn>GlobalEventHandlers</dfn></code> interface is defined in [[!HTML]].
        </p>
        <p>TBD.</p>
      </section>

    </section>

    <section>
      <h2>User Interactions</h2>

      <p>The user agent should allow the user to change the <a>selection</a> associated with the <dfn>active document</dfn>
        (<a href="https://www.w3.org/TR/html5/browsers.html#active-document">defined</a> in [[!HTML]]).
        If the user makes any modification to a <a>selection</a>, <a>ComposedSelection</a> must refer the updated <a>selection</a>.

      <p>The user agent must not make a <a>selection</a> <a>empty</a> if it was not already <a>empty</a>
        in response to any user actions (e.g. clicking on a non-editable region).</p>

    </section>

    <section class='appendix'>
      <h2>Acknowledgements</h2>
      <p>Many thanks to</p>
      <ul>
        <li><p>Ryosuke Niwa, who is the original author of <a href="http://w3c.github.io/selection-api/">Selection API</a>.</p></li>
        <li>TBD. </li>
    </section>

  </body>
</html>
